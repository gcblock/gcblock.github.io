(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{415:function(e,i,n){"use strict";n.r(i);var t=n(42),r=Object(t.a)({},(function(){var e=this,i=e.$createElement,n=e._self._c||i;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("/*")]),e._v(" "),n("ul",[n("li",[e._v("Licensed to the Apache Software Foundation (ASF) under one")]),e._v(" "),n("li",[e._v("or more contributor license agreements.  See the NOTICE file")]),e._v(" "),n("li",[e._v("distributed with this work for additional information")]),e._v(" "),n("li",[e._v("regarding copyright ownership.  The ASF licenses this file")]),e._v(" "),n("li",[e._v("to you under the Apache License, Version 2.0 (the")]),e._v(" "),n("li",[e._v('"License"); you may not use this file except in compliance')]),e._v(" "),n("li",[e._v("with the License.  You may obtain a copy of the License at")]),e._v(" "),n("li"),e._v(" "),n("li",[e._v("http://www.apache.org/licenses/LICENSE-2.0")]),e._v(" "),n("li"),e._v(" "),n("li",[e._v("Unless required by applicable law or agreed to in writing,")]),e._v(" "),n("li",[e._v("software distributed under the License is distributed on an")]),e._v(" "),n("li",[e._v('"AS IS" BASIdS, WITHOUT WARRANTIES OR CONDITIONS OF ANY')]),e._v(" "),n("li",[e._v("KIND, either express or implied.  See the License for the")]),e._v(" "),n("li",[e._v("specific language governing permissions and limitations")]),e._v(" "),n("li",[e._v("under the License.\n*/")])]),e._v(" "),n("p",[e._v('var curveTool = require("zrender/lib/core/curve");')]),e._v(" "),n("p",[e._v('var vec2 = require("zrender/lib/core/vector");')]),e._v(" "),n("p",[e._v('var _graphHelper = require("./graphHelper");')]),e._v(" "),n("p",[e._v("var getSymbolSize = _graphHelper.getSymbolSize;")]),e._v(" "),n("p",[e._v("/*")]),e._v(" "),n("ul",[n("li",[e._v("Licensed to the Apache Software Foundation (ASF) under one")]),e._v(" "),n("li",[e._v("or more contributor license agreements.  See the NOTICE file")]),e._v(" "),n("li",[e._v("distributed with this work for additional information")]),e._v(" "),n("li",[e._v("regarding copyright ownership.  The ASF licenses this file")]),e._v(" "),n("li",[e._v("to you under the Apache License, Version 2.0 (the")]),e._v(" "),n("li",[e._v('"License"); you may not use this file except in compliance')]),e._v(" "),n("li",[e._v("with the License.  You may obtain a copy of the License at")]),e._v(" "),n("li"),e._v(" "),n("li",[e._v("http://www.apache.org/licenses/LICENSE-2.0")]),e._v(" "),n("li"),e._v(" "),n("li",[e._v("Unless required by applicable law or agreed to in writing,")]),e._v(" "),n("li",[e._v("software distributed under the License is distributed on an")]),e._v(" "),n("li",[e._v('"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY')]),e._v(" "),n("li",[e._v("KIND, either express or implied.  See the License for the")]),e._v(" "),n("li",[e._v("specific language governing permissions and limitations")]),e._v(" "),n("li",[e._v("under the License.\n*/\nvar v1 = [];\nvar v2 = [];\nvar v3 = [];\nvar quadraticAt = curveTool.quadraticAt;\nvar v2DistSquare = vec2.distSquare;\nvar mathAbs = Math.abs;")])]),e._v(" "),n("p",[e._v("function intersectCurveCircle(curvePoints, center, radius) {\nvar p0 = curvePoints[0];\nvar p1 = curvePoints[1];\nvar p2 = curvePoints[2];\nvar d = Infinity;\nvar t;\nvar radiusSquare = radius * radius;\nvar interval = 0.1;")]),e._v(" "),n("p",[e._v("for (var _t = 0.1; _t <= 0.9; _t += 0.1) {\nv1[0] = quadraticAt(p0[0], p1[0], p2[0], _t);\nv1[1] = quadraticAt(p0[1], p1[1], p2[1], _t);\nvar diff = mathAbs(v2DistSquare(v1, center) - radiusSquare);")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("if (diff < d) {\n  d = diff;\n  t = _t;\n}\n")])])]),n("p",[e._v("} // Assume the segment is monotone，Find root through Bisection method\n// At most 32 iteration")]),e._v(" "),n("p",[e._v("for (var i = 0; i < 32; i++) {\n// var prev = t - interval;\nvar next = t + interval; // v1[0] = quadraticAt(p0[0], p1[0], p2[0], prev);\n// v1[1] = quadraticAt(p0[1], p1[1], p2[1], prev);")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("v2[0] = quadraticAt(p0[0], p1[0], p2[0], t);\nv2[1] = quadraticAt(p0[1], p1[1], p2[1], t);\nv3[0] = quadraticAt(p0[0], p1[0], p2[0], next);\nv3[1] = quadraticAt(p0[1], p1[1], p2[1], next);\nvar diff = v2DistSquare(v2, center) - radiusSquare;\n\nif (mathAbs(diff) < 1e-2) {\n  break;\n} // var prevDiff = v2DistSquare(v1, center) - radiusSquare;\n\n\nvar nextDiff = v2DistSquare(v3, center) - radiusSquare;\ninterval /= 2;\n\nif (diff < 0) {\n  if (nextDiff >= 0) {\n    t = t + interval;\n  } else {\n    t = t - interval;\n  }\n} else {\n  if (nextDiff >= 0) {\n    t = t - interval;\n  } else {\n    t = t + interval;\n  }\n}\n")])])]),n("p",[e._v("}")]),e._v(" "),n("p",[e._v("return t;\n} // Adjust edge to avoid")]),e._v(" "),n("p",[e._v("function _default(graph, scale) {\nvar tmp0 = [];\nvar quadraticSubdivide = curveTool.quadraticSubdivide;\nvar pts = [[], [], []];\nvar pts2 = [[], []];\nvar v = [];\nscale /= 2;\ngraph.eachEdge(function (edge, idx) {\nvar linePoints = edge.getLayout();\nvar fromSymbol = edge.getVisual('fromSymbol');\nvar toSymbol = edge.getVisual('toSymbol');")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("if (!linePoints.__original) {\n  linePoints.__original = [vec2.clone(linePoints[0]), vec2.clone(linePoints[1])];\n\n  if (linePoints[2]) {\n    linePoints.__original.push(vec2.clone(linePoints[2]));\n  }\n}\n\nvar originalPoints = linePoints.__original; // Quadratic curve\n\nif (linePoints[2] != null) {\n  vec2.copy(pts[0], originalPoints[0]);\n  vec2.copy(pts[1], originalPoints[2]);\n  vec2.copy(pts[2], originalPoints[1]);\n\n  if (fromSymbol && fromSymbol !== 'none') {\n    var symbolSize = getSymbolSize(edge.node1);\n    var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale); // Subdivide and get the second\n\n    quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);\n    pts[0][0] = tmp0[3];\n    pts[1][0] = tmp0[4];\n    quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);\n    pts[0][1] = tmp0[3];\n    pts[1][1] = tmp0[4];\n  }\n\n  if (toSymbol && toSymbol !== 'none') {\n    var symbolSize = getSymbolSize(edge.node2);\n    var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale); // Subdivide and get the first\n\n    quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);\n    pts[1][0] = tmp0[1];\n    pts[2][0] = tmp0[2];\n    quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);\n    pts[1][1] = tmp0[1];\n    pts[2][1] = tmp0[2];\n  } // Copy back to layout\n\n\n  vec2.copy(linePoints[0], pts[0]);\n  vec2.copy(linePoints[1], pts[2]);\n  vec2.copy(linePoints[2], pts[1]);\n} // Line\nelse {\n    vec2.copy(pts2[0], originalPoints[0]);\n    vec2.copy(pts2[1], originalPoints[1]);\n    vec2.sub(v, pts2[1], pts2[0]);\n    vec2.normalize(v, v);\n\n    if (fromSymbol && fromSymbol !== 'none') {\n      var symbolSize = getSymbolSize(edge.node1);\n      vec2.scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale);\n    }\n\n    if (toSymbol && toSymbol !== 'none') {\n      var symbolSize = getSymbolSize(edge.node2);\n      vec2.scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale);\n    }\n\n    vec2.copy(linePoints[0], pts2[0]);\n    vec2.copy(linePoints[1], pts2[1]);\n  }\n")])])]),n("p",[e._v("});\n}")]),e._v(" "),n("p",[e._v("module.exports = _default;���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������")])])}),[],!1,null,null,null);i.default=r.exports}}]);